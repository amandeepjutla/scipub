}
# check if all one type of variable
type <- dplyr::case_when(
length(factor_vars) == 0 ~ "numeric",
length(factor_vars) == length(vars) ~ "factor",
TRUE ~ "mixed"
)
### create sub-function ###
grouptests <- function(datafile, groupvar, outcome, ...) {
perc <- NULL
y <- datafile[[outcome]]
x <- datafile[[groupvar]]
# set group names with N
grplvl <- stringr::str_c(levels(datafile[[groupvar]]), " (N=", (datafile %>%
dplyr::group_by_at(groupvar) %>%
dplyr::select(tidyselect::all_of(groupvar)) %>%
dplyr::tally())$n, ")", sep = "")
tableout <- c("Variable", grplvl, "Stat", "p", "sig", "es") %>%
purrr::map_dfc(stats::setNames, object = list(character())) %>%
tibble::add_row()
# IF NUMERIC
if (is.numeric(y)) {
tableout$Variable <- var_names[which(vars == outcome)]
# get mean (SD) per group
tableout[, grplvl] <- as.data.frame(t((datafile %>%
dplyr::group_by_at(groupvar) %>%
dplyr::select_at(outcome) %>%
dplyr::summarise_all(list(
mean = mean,
sd = stats::sd
), na.rm = TRUE) %>%
dplyr::mutate_at(c("mean", "sd"), round, round_n) %>%
tidyr::unite("col", mean, sd, sep = " (") %>%
dplyr::mutate(col = stringr::str_c(col, ")")))[2]))
# IF 2 LEVEL
if (groupvar != "onecol" & sum(table(x,!is.na(y))[,2]>0)==2) {
testtype <- ifelse(type == "mixed", "t=", "")
# calcualte t-test & p-value
tableout$Stat <- paste0(testtype,
format(round(
-1 * stats::t.test(y ~ x)$statistic,
round_n
), nsmall = round_n),
sep = ""
)
# -1* to flip so t direction is g2>g1
p <- stats::t.test(y ~ x)$p.value
# calculate effect size - cohens d
estype <- ifelse(type == "mixed", "d=", "")
tableout$es <- paste0(estype, format(round(
(datafile %>%
dplyr::group_by_at(groupvar) %>%
dplyr::select_at(outcome) %>%
dplyr::summarise_all(list(mean = mean, sd = stats::sd),
na.rm = TRUE
) %>%
tidyr::drop_na()  %>%
dplyr::mutate(d = (mean[2] - mean[1]) /
(sqrt((sd[2]^2 + sd[1]^2) / 2))))[[1, "d"]],
round_n
), nsmall = round_n))
# IF MORE THAN 2 LEVELS
} else if (groupvar != "onecol" & sum(table(x,!is.na(y))[,2]>0)>2) {
testtype <- ifelse(type == "mixed", "F=", "")
# calcualte anova & p-value
tableout$Stat <- paste0(testtype,
format(round(
summary(stats::aov(y ~ x))[[1]][[4]][1],
round_n
), nsmall = round_n),
sep = ""
)
p <- summary(stats::aov(y ~ x))[[1]][[5]][1]
# calculate effect size - cohens d
estype <- ifelse(type == "mixed", paste0("\u03B7", "2="), "")
tableout$es <- paste0(
estype,
format(round(
((stats::anova(stats::aov(y ~ x))[1, 2] /
sum(stats::anova(stats::aov(y ~ x))[, 2]))),
round_n
),
nsmall = round_n
)
)
}
# IF FACTOR
} else {
if (groupvar != "onecol") {
p <- stats::chisq.test(y, x)$p.value
testtype <- ifelse(type == "mixed", paste0("\u03C7", "2="), "")
tableout$Stat <- paste0(testtype,
format(round(stats::chisq.test(y, x)$statistic, round_n),
nsmall = round_n
),
sep = ""
)
}
# IF 2 LEVEL
if (sum(table(x,!is.na(y))[,2]>0)==2) {
lvl2 <- levels(y)[2]
tableout$Variable <- paste0(
var_names[which(vars == outcome)],
" (", lvl2, ")"
)
# get N (%)
tableout[, grplvl] <- as.data.frame(t((datafile %>%
tidyr::drop_na(tidyselect::all_of(outcome)) %>%
dplyr::group_by_at(c(groupvar, outcome)) %>%
dplyr::select_at(outcome) %>%
tally() %>%
dplyr::ungroup() %>%
dplyr::group_by_at(c(groupvar)) %>%
dplyr::mutate(perc = 100 * n / sum(n)) %>%
dplyr::mutate_at(c("perc"), round, round_n) %>%
tidyr::unite("col", n, perc, sep = " (") %>%
dplyr::mutate(col = stringr::str_c(col, "%)")) %>%
dplyr::filter(base::get(outcome) == lvl2))$col))
# calculate effect size - odds ratio
if (sum(table(x,!is.na(y))[,2]>0)==2 & groupvar != "onecol") {
estype <- ifelse(type == "mixed", "OR=", "")
tableout$es <- paste0(
estype,
format(round(stats::fisher.test(x, y)$estimate, round_n),
nsmall = round_n
)
)
} else if (sum(table(x,!is.na(y))[,2]>0)>2 & groupvar != "onecol") {
# calculate effect size - cramer v
estype <- ifelse(type == "mixed", "V=", "")
tableout$es <- paste0(
estype,
format(round(sqrt((stats::chisq.test(y, x)$statistic) /
(sum(stats::complete.cases(cbind(y, x))) *
stats::chisq.test(y, x)$parameter)), round_n),
nsmall = round_n
)
)
}
# IF MORE THAN 2 LEVELS
} else {
tableout$Variable <- outcome
tableout[2:(1 + length(levels(y))), grplvl] <- datafile %>%
tidyr::drop_na(tidyselect::all_of(outcome)) %>%
dplyr::group_by_at(c(groupvar, outcome)) %>%
dplyr::select_at(outcome) %>%
tally() %>%
dplyr::ungroup() %>%
dplyr::group_by_at(c(groupvar)) %>%
dplyr::mutate(perc = 100 * n / sum(n)) %>%
dplyr::mutate_at(c("perc"), round, round_n) %>%
tidyr::unite("col", n, perc, sep = " (") %>%
dplyr::mutate(col = stringr::str_c(col, "%)")) %>%
tidyr::spread(groupvar, "col") %>%
dplyr::select(-c(tidyselect::all_of(outcome)))
tableout$Variable[2:(1 + length(levels(y)))] <- levels(y)
# calculate effect size - cramer v
estype <- ifelse(type == "mixed", "V=", "")
if (groupvar != "onecol") {
tableout$es[1] <- paste0(
estype,
format(round(sqrt((stats::chisq.test(y, x)$statistic) /
(sum(stats::complete.cases(cbind(y, x))) *
stats::chisq.test(y, x)$parameter)), round_n),
nsmall = round_n
)
)
}
}
}
# set p for all test types
if (groupvar != "onecol" & !is.null(p)) {
tableout$sig[1] <- ifelse(p < .001, "***",
ifelse(p < .01, "**", ifelse(p < .05, "*", ""))
)
tableout$p[1] <- ifelse(p < .001, "<.001",
ifelse(p < .01, sub(format(round(p, 3), nsmall = 3),
pattern = "0.", replacement = "."
),
sub(format(round(p, 2), nsmall = 2),
pattern = "0.", replacement = "."
)
)
)
}
return(tableout)
}
# iterate on all variables
finaltable <- do.call("rbind", lapply(
vars,
function(x) {
grouptests(
datafile = data_edit,
groupvar = strata,
outcome = x
)
}
))
# FINAL FORMATTING
# remove es if not requested
if (!es_col[1]) {
finaltable <- finaltable %>% dplyr::select(-c(es))
}
# remove p if not requested
if (!p_col[1]) {
finaltable <- finaltable %>% dplyr::select(-c(p))
}
# remove p if not requested
if (strata == "onecol") {
finaltable <- finaltable %>% dplyr::select(-c(Stat))
}
if (stars[1] == "name") {
finaltable <- finaltable %>%
tidyr::unite(Variable, Variable, sig, sep = " ")
} else if (stars[1] == "stat") {
finaltable <- finaltable %>% tidyr::unite(Stat, Stat, sig, sep = " ")
} else if (stars[1] == "none") {
finaltable <- finaltable %>% dplyr::select(-c(sig))
}
#remove missing cells
finaltable[is.na(finaltable)] <- "-"
finaltable[finaltable=="NaN (NA)"] <- "-"
# caption
missing_n <- data_edit %>%
dplyr::select(tidyselect::all_of(vars)) %>%
purrr::set_names(var_names) %>%
dplyr::mutate_all(is.na) %>%
dplyr::summarise_all(sum) %>%
dplyr::select_if(function(sum) sum > 0)
missingness <- ifelse(ncol(missing_n) > 0,
paste0(stringr::str_c(
"N=", missing_n,
" missing ", colnames(missing_n), ". "
),
collapse = ""
),
""
)
caption <- paste0(
"Note. ",
ifelse(sum(is.na(data[[strata]])) > 0,
paste0(
"N=", sum(is.na(data[[strata]])),
" excluded for missing group variable. "
), ""
),
missingness,
ifelse(strata == "onecol", "", "* p<.05, ** p<.01, *** p<.001")
)
# check if htmlTable installed
if (html[1] == TRUE & !requireNamespace("htmlTable", quietly = TRUE)) {
warning("library(htmlTable) is needed for HTML format output,
please install and try again")
html <- FALSE
}
if (html[1] == TRUE) {
return(print(htmlTable::htmlTable(finaltable,
useViewer = TRUE, rnames = FALSE,
caption = caption,
pos.caption = "bottom"
)))
} else {
return(list(
table = noquote(as.data.frame(finaltable, row.names = NULL)),
caption = caption
))
}
}
FullTable1(
data = tmp,
vars = c("Age", "Height", "depressT"), strata = "Income", html = T)
partial_correltable(data = psydat, vars = c("Age", "Height", "iq"), partialvars = c("Sex", "Income"), tri = "lower", html = TRUE)
partial_correltable(data = psydat, vars = c("Age", "Height", "iq"), var_names = c("Age (months)", "Height (inches)", "IQ"), partialvars = c("Sex", "Income"),tri = "upper", colnum = TRUE, html = TRUE)
partial_correltable(data = psydat, vars = c("Age", "Height", "iq"), var_names = c("Age (months)", "Height (inches)", "IQ"), partialvars = c("Sex", "Income"),tri = "upper", method = "spearman", use = "complete", cutempty = TRUE, colnum = TRUE, html = TRUE)
cranlogs_badge("scipub", summary = "grand-total")
library(cranlogs)
cranlogs_badge("scipub", summary = "grand-total")
#' Create partial correlation table (with stars for significance)
#'  for scientific publication
#'
#' The `partial_correltable` function can be used to create
#' partial correlation
#' table (with stars for significance) for scientific publication
#' This is intended to summarize partial correlations
#'  between (`vars`) from an input dataset (`data`),
#'  residualizing all `vars` by `partialvars`.
#' This function allows for numeric, binary, and factor
#'  variables as `partialvars`. but only numeric `vars`
#'  are used and any non-numeric `vars` will be dropped.
#'  All other flags follow from `scipub::correltable`.
#' Correlations are based on `stats::cor`, `use` and `method`
#'  follow from that function.
#' Stars indicate significance: `*p<.05, **p<.01, ***p<.001`
#' For formatting, variables can be renamed, numbers can be rounded,
#'  upper or lower triangle only can be selected (or whole matrix),
#'   and empty columns/rows can be dropped if using triangles.
#' For more compact columns, variable names can be numbered in the
#'  rows and column names will be corresponding numbers.
#' Requires `tidyverse` and `stats` libraries.
#' @param data The input dataset.
#' @param vars A list of the names of 2+ variables to correlate,
#'  e.g. c("Age","height","WASI"). All variables must be numeric.
#' @param var_names An optional list to rename the `vars` colnames
#'  in the output table, e.g. c("Age (years)","Height (inches)","IQ").
#'   Must match `vars` in length. If not supplied, `vars` will be printed as is.
#' @param partialvars A list of the names of 1+ variables to partial out,
#'  e.g. c("iq","Sex","Income"). Can include numeric, binary, factor variables.
#' @param partialvar_names An optional list to rename the `partialvars`
#' colnames in the output table, e.g. c("IQ (WASI)","Sex","Income").
#'   Must match `partialvar_names` in length.
#'   If not supplied, `partialvar_names` will be printed as is.
#' @param method Type of correlation to calculate c("pearson", "spearman"),
#'  based on `stats::cor`, default = "pearson".
#' @param use  Use pairwise.complete.obs or restrict to complete cases
#'  c("pairwise", "complete"), based on `stats::cor`, default = "pairwise".
#' @param round_n The number of decimal places to
#'  round all output to (default=2).
#' @param tri Select output formatting c("upper", "lower","all");
#'  KEEP the upper triangle, lower triangle, or all values, default ="upper.
#' @param cutempty If keeping only upper/lower triangle with `tri`,
#'  cut empty row/column, default=FALSE.
#' @param colnum For more concise column names, number row names and
#'  just use corresponding numbers as column names,
#'   default=FALSE, if TRUE overrides cutempty.
#' @param html Format as html in viewer or not (default=F, print in console),
#'  needs library(htmlTable) installed.
#' @return Output Table 1
#' @import 	dplyr
#' @importFrom 	purrr negate
#' @importFrom 	stats lm resid setNames
#' @import 	stringr
#' @importFrom 	tidyselect all_of
#' @export
#' @examples
#' partial_correltable(
#'   data = psydat, vars = c("Age", "Height", "iq"),
#'   partialvars = c("Sex", "Income"),
#'   tri = "lower", html = TRUE
#' )
#'
#' partial_correltable(
#'   data = psydat, vars = c("Age", "Height", "iq"),
#'   var_names = c("Age (months)", "Height (inches)", "IQ"),
#'   partialvars = c("Sex", "Income"),
#'   tri = "upper", colnum = TRUE, html = TRUE
#' )
#'
#' partial_correltable(
#'   data = psydat, vars = c("Age", "Height", "iq"),
#'   var_names = c("Age (months)", "Height (inches)", "IQ"),
#'   partialvars = c("anxT"),
#'   partialvar_names = "Anxiety",
#'   tri = "all", html = TRUE
#' )
#'
partial_correltable <- function(data, vars = NULL, var_names = vars,
partialvars = NULL,
partialvar_names = partialvars,
method = c("pearson", "spearman"),
use = c("pairwise", "complete"),
round_n = 2,
tri = c("upper", "lower", "all"),
cutempty = c(FALSE, TRUE),
colnum = c(FALSE, TRUE),
html = c(FALSE, TRUE)) {
# remove duplicates
var_names <- var_names[!duplicated(vars)]
vars <- vars[!duplicated(vars)]
partialvar_names <- partialvar_names[!duplicated(partialvars)]
partialvars <- partialvars[!duplicated(partialvars)]
# REMOVE NON-NUMERIC FROM VARS
if (ncol(data %>%
dplyr::select(vars) %>%
dplyr::select_if(purrr::negate(is.numeric))) > 0) {
warning(paste0(
"Dropping non-numeric vars: ",
stringr::str_c(colnames(data %>%
dplyr::select(vars) %>%
dplyr::select_if(purrr::negate(is.numeric))),
sep = " ", collapse = ","
)
), call. = FALSE)
var_names <- var_names[-which(vars %in%
names(data %>%
dplyr::select(vars) %>%
dplyr::select_if(purrr::negate(is.numeric))))]
data <- dplyr::select(
data,
-names(data %>%
dplyr::select(vars) %>%
dplyr::select_if(purrr::negate(is.numeric)))
)
}
if (sum(partialvars %in% vars) > 0) {
warning(paste0(
"variable in both vars and partialvars dropped from partialvars: ",
partialvars[partialvars %in% vars]
), call. = FALSE)
partialvar_names <- partialvar_names[!(partialvars %in% vars)]
partialvars <- partialvars[!(partialvars %in% vars)]
}
# check if vars is missing
if (length(vars) < 2) {
stop("not enough vars have been declared", call. = FALSE)
}
if (length(partialvars) < 1) {
stop("no partialvars have been declared", call. = FALSE)
}
# Check var_names
if (length(var_names) != length(vars)) {
stop("length of var_names does not match length of vars", call. = FALSE)
}
if (length(partialvar_names) != length(partialvars)) {
stop("length of partialvar_names does not match
length of partialvars", call. = FALSE)
}
# select data
varsall <- c(vars, partialvars)
x <- data %>%
dplyr::select(tidyselect::all_of(varsall))
# if incomplete cases - set all data  na
if (stringr::str_detect(use[1], "complete")) {
x[!complete.cases(x), ] <- NA
} else {
# Make vars NA when any partialvars missing
x <- x[complete.cases(x[, partialvars]), ]
# count missingness in partial variables
missing_n <- sum(!complete.cases(data %>%
dplyr::select(tidyselect::all_of(partialvars))))
missingness <- ifelse(missing_n > 0,
paste0(
"N=", missing_n,
" excluded for missing covariates to be partialled out. * p<.05",
collapse = ""
),
""
)
}
# create blank residual data frame
resdat <- stats::setNames(data.frame(matrix(
ncol = length(vars),
nrow = NROW(x)
)), vars)
# residualize all vars variables by partialvars
resdat[, vars] <- lapply(vars, function(a) {
stats::resid(stats::lm(
data = x,
as.formula(paste("scale(", a, ") ~",
paste(partialvars, collapse = "+"),
sep = ""
)),
na.action = "na.exclude"
))
})
# use scipub::correltable on residualized data
tabout <- scipub::correltable(
data = resdat, var_names = var_names,
use = use[1],
method = method[1],
round_n = round_n,
tri = tri[1],
cutempty = cutempty[1],
colnum = colnum[1],
html = FALSE
)
caption <- stringr::str_replace(
string = tabout$caption,
pattern = "correlation coefficients",
replacement = paste0(
"partial correlation coefficients controlling for ",
paste0(partialvar_names, collapse = ", ")
)
)
if (!stringr::str_detect(use[1], "complete")) {
caption <- stringr::str_replace(
string = caption,
pattern = "\\* p<.05",
replacement = missingness
)
}
rmat <- tabout$table
# check if htmlTable installed
if (html[1] == TRUE & !requireNamespace("htmlTable", quietly = TRUE)) {
warning("library(htmlTable) is needed for HTML format output,
please install and try again")
html <- FALSE
}
if (html[1] == TRUE) {
return(print(htmlTable::htmlTable(rmat,
useViewer = TRUE, caption = caption, pos.caption = "bottom"
)))
} else {
return(list(table = noquote(rmat), caption = caption))
}
}
partial_correltable(data = psydat, vars = c("Age", "Height", "iq"), partialvars = c("Sex", "Income"), tri = "lower", html = TRUE)
library(devtools)
library(roxygen2)
#setwd("/Users/David/Dropbox (Personal)")
#create("scipub")
setwd("/Users/David/Dropbox (Personal)/scipub")
devtools::check(document = T,cran = F,vignettes =T)
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_news_md()
usethis::use_build_ignore(c("_config.yml" ,"scipub.pdf" ,"scipub_1.0.0.tar.gz"))
devtools::build()
devtools::install()
#spelling::spell_check_setup()
spelling::spell_check_package()
styler:::style_active_pkg()
devtools::install_github("dpagliaccio/scipub",force=T,dependencies = T)
